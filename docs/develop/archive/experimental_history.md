# 實驗與探索歷程

## 概述

本文檔記錄專案開發過程中的重要實驗與探索，包括條紋偽陽性問題的解決歷程，以及高斯缺陷生成的設計演進。

---

## 條紋偽陽性問題解決歷程（2024-08 ~ 2025-01）

### 問題描述

**發現時間**：2024 年 8 月初，完成主要優化後

**問題表現**：
- 當圖案有條紋時，三通道的亮度變化導致模型誤判為缺陷
- 強烈的 false positive（偽陽性）反應
- 影響範圍：帶有線條或條紋圖案的測試樣本

---

### 解決方案演進

#### 版本 1：Edge Negative Dataloader (60f3621, 2024-08-14)

**概念**：使用 Canny 邊緣檢測增強現有邊緣

**實作方式**：
- 檢測原圖邊緣 → 膨脹 → 高斯模糊
- 三種增強模式：brightness、mixed、noise
- 10% 機率額外加入條紋圖案

**問題**：
- ❌ **邏輯錯誤**：依賴原圖已有邊緣才生成負樣本
- ❌ 訓練集通常無線條，無法有效生成負樣本
- 程式碼量：+1292 行

**結論**：方向錯誤，無法解決問題

---

#### 版本 2：Patch Edge Function (73586a3, 2024-08)

**概念**：改進版本 1，先檢查是否有結構邊緣

**實作方式**：
- 新增 `_has_structural_edges` 函數
- 邊緣像素比例 > 2% 才生成負樣本
- 否則改為生成點缺陷

**問題**：
- ❌ **本末倒置**：訓練集通常無線條，條件永遠不滿足
- ❌ 實際上幾乎不會生成線條負樣本
- 程式碼量：+402 行

**結論**：仍未解決根本問題

---

#### 版本 3：Simple Line Defect (27bfb55, 2024-08) ✅

**概念**：直接生成合成線條作為負樣本

**實作方式**：
```python
# 生成 1-3 條隨機線條
num_lines = np.random.randint(1, 4)

# 線條參數
width = np.random.randint(1, 3)  # 1-2 pixels 寬
intensity = calculate_smart_intensity(background)  # 智慧強度計算

# 三通道強度分配
- Target: 100% 強度
- Ref1:   60% 強度
- Ref2:   60% 強度

# GT mask 全零（線條非缺陷）
```

**優點**：
- ✅ 方向正確：主動生成，不依賴原圖
- ✅ 實作簡潔：約 200 行核心程式碼
- ✅ 有效訓練：明確標記線條為非缺陷（GT = 0）

**程式碼量**：-350 行（簡化）

**結論**：簡單有效的解決方案

---

#### 版本 4：Complex Line + Point (956c79b, 2024-09)

**概念**：過度工程化的解決方案

**實作方式**：
- 線條 + 點缺陷組合（`_generate_line_with_point_defects`）
- 真實線條檢測與避讓（`_detect_real_lines`）
- 複雜線條生成：
  - 2-6 pixels 寬度
  - 軟邊緣（高斯模糊）
  - 斑點變化
- 點缺陷避開線條位置

**問題**：
- 🤔 **過度複雜**：難以維護和調試
- 🤔 **效果存疑**：複雜不等於有效
- 🤔 **可讀性差**：邏輯分散在多個函數

**程式碼量**：+553 行（爆炸性增長）

**結論**：違反簡潔原則

---

### 最終決策（2025-01-14）

**選擇**：回退到版本 3（Simple Line Defect）

**原因**：
1. ✅ 版本 1-2 方向錯誤
2. ✅ 版本 3 簡潔有效
3. ✅ 版本 4 過度複雜

**提交記錄**：
```
commit 1a513e0: revert: Roll back dataloader to version 3 (simpler line generation)
- 移除 551 行複雜程式碼
- 保留簡單線條生成邏輯
```

---

### 最終採用的策略

**決定**：完全移除線條負樣本，回歸純點缺陷

**當前策略**（2025-01-18）：
- **100% 點缺陷**：只使用 3×3 和 3×5 高斯點缺陷
- **50% 生成機率**：50% patch 有缺陷，50% 正常
- **智慧分配**：確保 1-2 個 target-only 缺陷

**優點**：
- ✅ 最大化簡潔性
- ✅ 專注於核心對比學習
- ✅ 易於理解和維護
- ✅ 效果穩定可靠

---

## 高斯缺陷生成設計演進

### 初期設計（2024 年初）

**缺陷類型**：
- 可變大小：10-30 pixels
- 可變 sigma：依據大小動態調整
- 隨機強度：±30-50

**問題**：
- 變化太大，難以控制
- 缺陷大小不一致
- 訓練不穩定

---

### 中期調整（2024-08）

**標準化缺陷類型**：
- **3×3 缺陷**：sigma = 1.0
- **3×5 缺陷**：sigma = (1.0, 1.5)
- **固定強度**：[-50, -30, 30, 50]

**改進**：
- ✅ 缺陷大小統一
- ✅ 訓練更穩定
- ✅ 效果可重現

**問題**：
- Binary mask 太小（sigma = 1.0 對 3×3 太小）
- 缺陷強度不夠明顯

---

### 當前版本（2025-01）

**最終參數**：
- **3×3 缺陷**：sigma = **1.3**（提升）
- **3×5 缺陷**：sigma = (1.0, 1.5)（不變）
- **缺陷強度**：**[-80, -60, 60, 80]**（提升 60%）

**改進**：
- ✅ Binary mask 大小合適
- ✅ 缺陷更明顯
- ✅ 訓練效果更好

**融合方式**：
```python
# 直接相加法（利用高斯自然漸變）
output = background + defect_image * intensity
output = np.clip(output, 0, 255)
```

**優勢**：
- 自然漸變：高斯分布本身提供平滑邊緣
- 背景保留：使用相對變化，保留原始紋理
- 計算簡單：單一加法運算

---

## 經驗教訓

### 成功要素

1. ✅ **簡潔優於複雜**
   - 版本 3 的簡單線條勝過版本 4 的複雜實作
   - 最終回歸純點缺陷策略最為有效

2. ✅ **主動生成優於被動檢測**
   - 版本 1-2 依賴原圖特徵（失敗）
   - 版本 3 主動生成（成功）

3. ✅ **明確標記非缺陷**
   - 使用 GT = 0 明確告訴模型「線條不是缺陷」
   - 對比學習的關鍵

4. ✅ **參數實驗與調整**
   - Sigma 從 1.0 → 1.3
   - 強度從 ±50 → ±80
   - 持續改進

### 失敗教訓

1. ❌ **避免依賴檢測**
   - 依賴原圖邊緣的方法無效
   - 訓練集特性限制了方法可行性

2. ❌ **複雜不等於有效**
   - 版本 4 的複雜實作並未帶來更好效果
   - 反而增加維護成本

3. ❌ **缺乏驗證的實驗**
   - 版本 1-2 沒有充分驗證就實作
   - 應該先小規模測試假設

---

## 實驗時間線

```
2024-01  ├─ 初期高斯缺陷設計（可變大小）
2024-08  ├─ 標準化缺陷類型（3×3, 3×5）
         ├─ 條紋問題發現
         ├─ 版本 1: Edge Negative (失敗)
         ├─ 版本 2: Patch Edge (失敗)
         └─ 版本 3: Simple Line (成功)
2024-09  └─ 版本 4: Complex Line (過度複雜)
2025-01  ├─ 回退到版本 3
         ├─ Sigma 調整（1.0 → 1.3）
         ├─ 強度提升（±50 → ±80）
         └─ 最終決定：移除線條，純點缺陷
```

---

## 測試工具（已移除）

在實驗過程中開發的測試工具（現已刪除）：

1. **compare_models.py**
   - 比較不同模型對各類缺陷的反應
   - 用於評估線條負樣本效果

2. **test_shape_penalty.py**
   - 測試後處理形狀懲罰機制
   - 嘗試在推理時過濾線條狀預測

3. **dataloader_v4_backup.py**
   - 版本 4 的備份
   - 保留作為參考

---

## 結論

經過四個版本的迭代和數月的實驗，最終發現：

**簡單直接的方法往往最有效**

版本 3 的簡潔實作在保持程式碼可維護性的同時，提供了合理的解決方案。而最終回歸純點缺陷策略，則是對「專注核心、避免過度設計」原則的最佳實踐。

**對比學習才是核心**

條紋偽陽性問題讓我們意識到，問題的根本不在於缺陷類型，而在於三通道對比學習機制本身。強化對比學習（智慧分配策略）比增加負樣本類型更為重要。

**持續改進勝過一次完美**

從可變大小 → 固定大小 → 參數微調，每次小步改進都帶來實質提升。這比追求一次性的完美設計更為實際。
