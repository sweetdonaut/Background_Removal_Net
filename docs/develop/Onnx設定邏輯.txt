  ğŸ¯ ONNX æ‰“åŒ…ç­–ç•¥æ¦‚è¦½

  æˆ‘å€‘æ¡ç”¨äº†ä¸‰å±¤åŒ…è£æ¶æ§‹ï¼Œå°‡æ¨ç†çš„æ¯å€‹éšæ®µé€æ­¥å°è£é€² ONNX æ¨¡å‹ï¼š

  Layer 1: SegmentationNetwork (åŸºç¤åˆ†å‰²)
      â†“
  Layer 2: SegmentationNetworkONNX (Patch ç´šåˆ¥è™•ç†)
      â†“
  Layer 3: SegmentationNetworkONNXFullImage (å®Œæ•´åœ–ç‰‡è™•ç†)

  è®“æˆ‘é€å±¤è§£é‡‹ï¼š

  ---
  ğŸ“¦ Layer 1: SegmentationNetworkï¼ˆåŸºç¤åˆ†å‰²ï¼‰

  åŠŸèƒ½ï¼šç´”ç²¹çš„ UNet åˆ†å‰²ç¶²è·¯

â— Read(~/vscode_project/Background_Removal_Net/model.py)
  â¿ Â Read 20 lines

â— Layer 1 è™•ç†ï¼š
  Input:  (B, 3, H, W)  # ä¸‰é€šé“ (Target, Ref1, Ref2)
     â†“
  UNet Forward
     â†“
  Output: (B, 2, H, W)  # äºŒåˆ†é¡ logits (èƒŒæ™¯/å‰æ™¯)

  ---
  ğŸ“¦ Layer 2: SegmentationNetworkONNXï¼ˆPatch ç´šåˆ¥è™•ç†ï¼‰

  åŠŸèƒ½ï¼šç‚ºå–®å€‹ patch æ·»åŠ å¾Œè™•ç†

â— Read(~/vscode_project/Background_Removal_Net/model.py)
  â¿ Â Read 35 lines

â— Layer 2 è™•ç†ï¼š
  Input:  (B, 3, 128, 128)  # å–®å€‹ patch
     â†“
  Base Model (Layer 1)
     â†“ (B, 2, 128, 128)
  Softmax
     â†“ (B, 2, 128, 128) [probabilities]
  Extract Channel 1 (å‰æ™¯)
     â†“ (B, 1, 128, 128)
  Add 2 Zero Channels
     â†“
  Output: (B, 3, 128, 128)  # [ç•°å¸¸åœ–, é›¶, é›¶]

  ç‚ºä»€éº¼è¦ 3 é€šé“è¼¸å‡ºï¼Ÿ
  - ç”Ÿç”¢ç’°å¢ƒéœ€æ±‚ï¼ˆçµ±ä¸€æ ¼å¼ï¼‰
  - Channel 0ï¼šç•°å¸¸ heatmapï¼ˆå¯¦éš›ä½¿ç”¨ï¼‰
  - Channel 1-2ï¼šé ç•™æ“´å±•ç©ºé–“

  ---
  ğŸ“¦ Layer 3: SegmentationNetworkONNXFullImageï¼ˆå®Œæ•´åœ–ç‰‡è™•ç†ï¼‰

  é€™æ˜¯é—œéµï¼ å°‡åˆ†å‰²ã€æ»‘å‹•çª—å£ã€æ‹¼æ¥å…¨éƒ¨å°è£é€² ONNX

â— Read(~/vscode_project/Background_Removal_Net/model.py)
  â¿ Â Read 116 lines

â— Layer 3 è™•ç†ï¼ˆå®Œæ•´åœ–ç‰‡ï¼‰ï¼š

  Input: (1, 3, 976, 176)  # å®Œæ•´ strip åœ–ç‰‡
     â†“
  åˆå§‹åŒ–è¼¸å‡º heatmap (1, 1, 976, 176) = å…¨é›¶
     â†“
  for y_idx in 9 å€‹ Y ä½ç½®:
      for x_idx in 2 å€‹ X ä½ç½®:
          1. æå– patch (1, 3, 128, 128)
             â†“
          2. Patch Model (Layer 2)
             â†“ (1, 3, 128, 128)
          3. å– Channel 0
             â†“ (1, 1, 128, 128)
          4. æ™ºæ…§è£åˆ‡ï¼ˆä¸­å¿ƒå€åŸŸæ‹¼æ¥ç­–ç•¥ï¼‰
             - ç¬¬ä¸€å€‹ patchï¼šä¿ç•™é ‚éƒ¨
             - ä¸­é–“ patchesï¼šåªç”¨ä¸­å¿ƒ
             - æœ€å¾Œ patchï¼šä¿ç•™åº•éƒ¨
             â†“
          5. æ”¾å…¥å°æ‡‰ä½ç½®ï¼ˆç„¡ç¸«æ‹¼æ¥ï¼‰
     â†“
  å®Œæ•´ heatmap (1, 1, 976, 176)
     â†“
  åŠ å…¥ 2 å€‹é›¶é€šé“
     â†“
  Output: (1, 3, 976, 176)  # [ç•°å¸¸åœ–, é›¶, é›¶]

  ---
  ğŸ”§ ONNX åŒ¯å‡ºæµç¨‹

  å®Œæ•´åŒ¯å‡ºè…³æœ¬ï¼ˆexport_onnx_fullimage.pyï¼‰ï¼š

  # 1. è¼‰å…¥è¨“ç·´å¥½çš„ checkpoint
  checkpoint = torch.load(checkpoint_path)

  # 2. å‰µå»º Layer 1 (åŸºç¤æ¨¡å‹)
  base_model = SegmentationNetwork(in_channels=3, out_channels=2)
  base_model.load_state_dict(checkpoint['model_state_dict'])

  # 3. åŒ…è£æˆ Layer 2 (Patch ç´šåˆ¥)
  patch_onnx_model = SegmentationNetworkONNX(base_model)

  # 4. åŒ…è£æˆ Layer 3 (Full Image)
  full_image_model = SegmentationNetworkONNXFullImage(patch_onnx_model)

  # 5. æº–å‚™ dummy input
  dummy_input = torch.randn(1, 3, 976, 176)

  # 6. åŒ¯å‡º ONNX
  torch.onnx.export(
      full_image_model,      # æ¨¡å‹ï¼ˆLayer 3ï¼ŒåŒ…å«æ‰€æœ‰é‚è¼¯ï¼‰
      dummy_input,           # ç¯„ä¾‹è¼¸å…¥
      output_path,           # è¼¸å‡ºæª”æ¡ˆè·¯å¾‘
      export_params=True,    # åŒ¯å‡ºåƒæ•¸
      opset_version=11,      # ONNX opset ç‰ˆæœ¬
      input_names=['input'],
      output_names=['output'],
      dynamic_axes={         # å…è¨± batch size å‹•æ…‹
          'input': {0: 'batch_size'},
          'output': {0: 'batch_size'}
      }
  )

  ç™¼ç”Ÿäº†ä»€éº¼ï¼Ÿ

  ç•¶åŸ·è¡Œ torch.onnx.export() æ™‚ï¼š
  1. PyTorch æœƒç”¨ dummy_input åŸ·è¡Œä¸€æ¬¡ forward()
  2. è¨˜éŒ„æ‰€æœ‰æ“ä½œï¼ˆåŒ…æ‹¬ for è¿´åœˆã€if æ¢ä»¶ã€è£åˆ‡ã€æ‹¼æ¥ï¼‰
  3. å°‡é€™äº›æ“ä½œè½‰æ›æˆ ONNX è¨ˆç®—åœ–
  4. æ‰€æœ‰é‚è¼¯éƒ½è¢«ã€Œå±•é–‹ã€ä¸¦åµŒå…¥ ONNX æª”æ¡ˆ

  çµæœï¼š
  - âœ… 9Ã—2 å€‹ patch çš„æå–é‚è¼¯ â†’ ONNX
  - âœ… 18 æ¬¡æ¨¡å‹æ¨ç† â†’ ONNX
  - âœ… æ™ºæ…§è£åˆ‡èˆ‡æ‹¼æ¥ â†’ ONNX
  - âœ… Softmax å’Œé€šé“è½‰æ› â†’ ONNX

  ä¸€åˆ‡éƒ½åœ¨ ONNX æª”æ¡ˆè£¡ï¼

  ---
  ğŸ“– ONNX æ¨¡å‹è®€å–èˆ‡ä½¿ç”¨

  æ–¹æ³• 1ï¼šä½¿ç”¨ ONNX Runtimeï¼ˆPythonï¼‰

â— Read(~/vscode_project/Background_Removal_Net/inference_onnx.py)
  â¿ Â Read 40 lines

â— å®Œæ•´çš„ä½¿ç”¨ç¯„ä¾‹ï¼š

  import onnxruntime as ort
  import numpy as np
  import tifffile

  # 1. è¼‰å…¥ ONNX æ¨¡å‹
  ort_session = ort.InferenceSession("model_fullimage.onnx")

  # 2. è¼‰å…¥åœ–ç‰‡
  image = tifffile.imread("test_image.tiff")  # (4, 976, 176) æˆ– (3, 976, 176)

  # 3. å‰è™•ç†
  # è½‰æ›æ ¼å¼ï¼šCHW â†’ HWC
  if image.shape[0] in [3, 4]:
      image = np.transpose(image, (1, 2, 0))  # (976, 176, 3 æˆ– 4)

  # åªä¿ç•™å‰ 3 é€šé“
  if image.shape[2] == 4:
      image = image[:, :, :3]  # (976, 176, 3)

  # 4. æº–å‚™è¼¸å…¥ï¼šHWC â†’ CHW + æ­£è¦åŒ– + batch dimension
  three_channel = np.stack([image[:,:,0], image[:,:,1], image[:,:,2]], axis=0)
  input_tensor = (three_channel / 255.0).astype(np.float32)
  input_tensor = np.expand_dims(input_tensor, 0)  # (1, 3, 976, 176)

  # 5. ONNX æ¨ç† - ä¸€æ¬¡å‘¼å«è™•ç†å®Œæ•´åœ–ç‰‡ï¼
  outputs = ort_session.run(None, {'input': input_tensor})
  output = outputs[0]  # (1, 3, 976, 176)

  # 6. æå–çµæœ
  anomaly_heatmap = output[0, 0, :, :]  # (976, 176) - Channel 0
  # output[0, 1, :, :] å…¨æ˜¯ 0
  # output[0, 2, :, :] å…¨æ˜¯ 0

  # 7. ä½¿ç”¨ heatmap
  import matplotlib.pyplot as plt
  plt.imshow(anomaly_heatmap, cmap='hot')
  plt.colorbar()
  plt.show()

  ---
  ğŸ” å…§éƒ¨æµç¨‹åœ–è§£

  è®“æˆ‘ç•«ä¸€å€‹å®Œæ•´çš„æµç¨‹åœ–ï¼š

  === ONNX æ¨¡å‹å…§éƒ¨ï¼ˆå…¨è‡ªå‹•ï¼‰ ===

  è¼¸å…¥åœ–ç‰‡ (1, 3, 976, 176)
           â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                                     â”‚
      Patch 1 (0, 0)                        Patch 18 (848, 48)
      (1,3,128,128)                         (1,3,128,128)
           â”‚                                     â”‚
      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
      â”‚ Layer 2 â”‚                           â”‚ Layer 2 â”‚
      â”‚ Patch   â”‚                           â”‚ Patch   â”‚
      â”‚ Model   â”‚                           â”‚ Model   â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
           â”‚(1,3,128,128)                        â”‚(1,3,128,128)
           â”‚ Ch0: heatmap                        â”‚ Ch0: heatmap
           â”‚                                     â”‚
      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
      â”‚æ™ºæ…§è£åˆ‡    â”‚                         â”‚æ™ºæ…§è£åˆ‡    â”‚
      â”‚ä¿ç•™é ‚éƒ¨    â”‚                         â”‚ä¿ç•™åº•éƒ¨    â”‚
      â”‚117 pixels â”‚                         â”‚117 pixels â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚                                     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                     ç„¡ç¸«æ‹¼æ¥
                         â”‚
                         â–¼
                å®Œæ•´ Heatmap
                (1, 1, 976, 176)
                         â”‚
                    åŠ å…¥é›¶é€šé“
                         â”‚
                         â–¼
                è¼¸å‡º (1, 3, 976, 176)
                - Ch0: ç•°å¸¸åœ– âœ“
                - Ch1: é›¶
                - Ch2: é›¶

  ---
  ğŸ’¡ é—œéµç†è§£

  1. æ‰€æœ‰é‚è¼¯éƒ½åœ¨ ONNX è£¡

  # å¤–éƒ¨ä½¿ç”¨æ™‚ï¼Œä¸éœ€è¦ï¼š
  âŒ æ‰‹å‹•åˆ‡å‰² patches
  âŒ è¿´åœˆè™•ç†æ¯å€‹ patch
  âŒ æ‰‹å‹•æ‹¼æ¥çµæœ
  âŒ è¨ˆç®—è£åˆ‡ä½ç½®

  # åªéœ€è¦ï¼š
  âœ… è¼‰å…¥åœ–ç‰‡
  âœ… å‰è™•ç†ï¼ˆè½‰æ ¼å¼ + æ­£è¦åŒ–ï¼‰
  âœ… ä¸€æ¬¡æ¨ç†å‘¼å«
  âœ… å–å‡º Channel 0

  2. ç‚ºä»€éº¼é€™æ¨£è¨­è¨ˆï¼Ÿ

  ç”Ÿç”¢ç’°å¢ƒçš„è€ƒé‡ï¼š
  æ–¹æ¡ˆ Aï¼ˆå‚³çµ±ï¼‰ï¼š
  Python è…³æœ¬
    â”œâ”€ åˆ‡å‰² 18 å€‹ patches
    â”œâ”€ 18 æ¬¡ ONNX å‘¼å«
    â”œâ”€ Python æ‹¼æ¥é‚è¼¯
    â””â”€ è¼¸å‡º

  å•é¡Œï¼š
  âŒ éœ€è¦ç¶­è­· Python ç¨‹å¼ç¢¼
  âŒ Python/C++ è·¨èªè¨€å‘¼å«é–‹éŠ·
  âŒ éƒ¨ç½²è¤‡é›œ

  æ–¹æ¡ˆ Bï¼ˆæˆ‘å€‘çš„ï¼‰ï¼š
  å–®ä¸€ ONNX æª”æ¡ˆ
    â””â”€ ä¸€æ¬¡å‘¼å«å®Œæˆæ‰€æœ‰äº‹

  å„ªé»ï¼š
  âœ… ç°¡å–®ï¼šåªæ˜¯å€‹æª”æ¡ˆ
  âœ… å¿«é€Ÿï¼šå…§éƒ¨å„ªåŒ–
  âœ… è·¨å¹³å°ï¼šONNX Runtime æ”¯æ´å¤šèªè¨€

  3. æª”æ¡ˆå…§å®¹

  ONNX æª”æ¡ˆåŒ…å«ï¼š
  - âœ… æ‰€æœ‰æ¨¡å‹æ¬Šé‡
  - âœ… Patch ä½ç½®ï¼ˆhardcoded: [0, 106, 212, ...]ï¼‰
  - âœ… è£åˆ‡é‚è¼¯ï¼ˆif y_idx == 0: ...ï¼‰
  - âœ… æ‹¼æ¥é‚è¼¯ï¼ˆoutput[y_start:y_end, ...] = patchï¼‰
  - âœ… Softmaxã€é€šé“è½‰æ›

  å¯¦éš›ä¸Šæ˜¯ä¸€å€‹å®Œæ•´çš„æ¨ç†å¼•æ“ï¼

  ---
  ğŸ”§ å…¶ä»–èªè¨€ä½¿ç”¨ç¯„ä¾‹

  C++ ç¯„ä¾‹

  #include <onnxruntime_cxx_api.h>

  // 1. å»ºç«‹ session
  Ort::Env env;
  Ort::SessionOptions session_options;
  Ort::Session session(env, "model_fullimage.onnx", session_options);

  // 2. æº–å‚™è¼¸å…¥
  std::vector<float> input_data(1 * 3 * 976 * 176);
  // ... å¡«å…¥è³‡æ–™ ...

  std::vector<int64_t> input_shape = {1, 3, 976, 176};
  auto input_tensor = Ort::Value::CreateTensor<float>(
      memory_info, input_data.data(), input_data.size(),
      input_shape.data(), input_shape.size()
  );

  // 3. æ¨ç†
  auto output_tensors = session.Run(
      Ort::RunOptions{nullptr},
      input_names, &input_tensor, 1,
      output_names, 1
  );

  // 4. å–å¾—çµæœ
  float* output_data = output_tensors[0].GetTensorMutableData<float>();
  // output_data[0 * 976 * 176 : 1 * 976 * 176] æ˜¯ Channel 0

  ---
  ğŸ“Š æ•ˆèƒ½æ¯”è¼ƒ

  | é …ç›®         | å‚³çµ±æ–¹æ¡ˆ            | æˆ‘å€‘çš„æ–¹æ¡ˆ   |
  |------------|-----------------|---------|
  | ONNX å‘¼å«æ¬¡æ•¸  | 18 æ¬¡            | 1 æ¬¡     |
  | Python ç¨‹å¼ç¢¼ | ~200 è¡Œ          | ~10 è¡Œ   |
  | è·¨èªè¨€é–‹éŠ·      | 18 æ¬¡            | 1 æ¬¡     |
  | éƒ¨ç½²è¤‡é›œåº¦      | ä¸­ç­‰              | æ¥µä½      |
  | ç¶­è­·æˆæœ¬       | éœ€åŒæ­¥ Python/ONNX | åªéœ€ ONNX |

  ---



